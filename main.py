from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, Message
from telegram.ext import (
    ApplicationBuilder, ContextTypes, CommandHandler,
    MessageHandler, CallbackQueryHandler, ConversationHandler, filters
)
import uuid
import os
from collections import Counter
import json
import logging
import asyncio
import threading
import time

# ØªÙØ¹ÙŠÙ„ Ø§Ù„Ù€ logging Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ ÙˆØ§Ù„Ø¹Ù…Ù„ÙŠØ§Øª
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO
)
logger = logging.getLogger(__name__)

# Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ø«Ø§Ø¨Øª Ù„Ø­ÙØ¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¯Ø§Ø®Ù„ ÙˆØ­Ø¯Ø© Ø§Ù„ØªØ®Ø²ÙŠÙ† (Volume)
DATA_DIR = "/mnt/data/"

# Ø£Ø³Ù…Ø§Ø¡ Ù…Ù„ÙØ§Øª Ø­ÙØ¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
ORDERS_FILE = os.path.join(DATA_DIR, "orders.json")
PRICING_FILE = os.path.join(DATA_DIR, "pricing.json")
INVOICE_NUMBERS_FILE = os.path.join(DATA_DIR, "invoice_numbers.json")
DAILY_PROFIT_FILE = os.path.join(DATA_DIR, "daily_profit.json")
COUNTER_FILE = os.path.join(DATA_DIR, "invoice_counter.txt")
LAST_BUTTON_MESSAGE_FILE = os.path.join(DATA_DIR, "last_button_message.json")

# ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¹Ø§Ù…Ø©
orders = {}
pricing = {}
invoice_numbers = {}
daily_profit = 0.0
last_button_message = {}

# Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø­ÙØ¸ Ø§Ù„Ù…Ø¤Ø¬Ù„
save_timer = None
save_pending = False
save_lock = threading.Lock()

# ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¹Ù†Ø¯ Ø¨Ø¯Ø¡ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª
def load_data():
    global orders, pricing, invoice_numbers, daily_profit, last_button_message

    os.makedirs(DATA_DIR, exist_ok=True)

    # Helper function to load a JSON file safely
    def load_json_file(filepath, default_value, var_name):
        if os.path.exists(filepath):
            with open(filepath, "r") as f:
                try:
                    data = json.load(f)
                    logger.info(f"Loaded {var_name} from {filepath} successfully.")
                    return data
                except json.JSONDecodeError:
                    logger.warning(f"{filepath} is corrupted or empty, reinitializing {var_name}.")
                except Exception as e:
                    logger.error(f"Error loading {filepath}: {e}, reinitializing {var_name}.")
        logger.info(f"{var_name} file not found or corrupted, initializing to default.")
        return default_value

    orders_temp = load_json_file(ORDERS_FILE, {}, "orders")
    orders.clear()
    orders.update({str(k): v for k, v in orders_temp.items()})

    pricing_temp = load_json_file(PRICING_FILE, {}, "pricing")
    pricing.clear()
    pricing.update({str(pk): pv for pk, pv in pricing_temp.items()})
    for oid in pricing:
        if isinstance(pricing[oid], dict):
            pricing[oid] = {str(pk): pv for pk, pv in pricing[oid].items()} # Ensure inner keys are strings too

    invoice_numbers_temp = load_json_file(INVOICE_NUMBERS_FILE, {}, "invoice_numbers")
    invoice_numbers.clear()
    invoice_numbers.update({str(k): v for k, v in invoice_numbers_temp.items()})

    daily_profit = load_json_file(DAILY_PROFIT_FILE, 0.0, "daily_profit")
    
    last_button_message_temp = load_json_file(LAST_BUTTON_MESSAGE_FILE, {}, "last_button_message")
    last_button_message.clear()
    last_button_message.update({str(k): v for k, v in last_button_message_temp.items()})

    logger.info(f"Initial load complete. Orders: {len(orders)}, Pricing entries: {len(pricing)}, Daily Profit: {daily_profit}")


# Ø­ÙØ¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
def _save_data_to_disk():
    global save_pending
    with save_lock:
        os.makedirs(DATA_DIR, exist_ok=True)
        try:
            # Save to temporary files first, then rename to prevent data corruption
            with open(ORDERS_FILE + ".tmp", "w") as f:
                json.dump(orders, f, indent=4) # Use indent for readability in files
            os.replace(ORDERS_FILE + ".tmp", ORDERS_FILE)

            with open(PRICING_FILE + ".tmp", "w") as f:
                json.dump(pricing, f, indent=4)
            os.replace(PRICING_FILE + ".tmp", PRICING_FILE)

            with open(INVOICE_NUMBERS_FILE + ".tmp", "w") as f:
                json.dump(invoice_numbers, f, indent=4)
            os.replace(INVOICE_NUMBERS_FILE + ".tmp", INVOICE_NUMBERS_FILE)

            with open(DAILY_PROFIT_FILE + ".tmp", "w") as f:
                json.dump(daily_profit, f, indent=4)
            os.replace(DAILY_PROFIT_FILE + ".tmp", DAILY_PROFIT_FILE)

            with open(LAST_BUTTON_MESSAGE_FILE + ".tmp", "w") as f:
                json.dump(last_button_message, f, indent=4)
            os.replace(LAST_BUTTON_MESSAGE_FILE + ".tmp", LAST_BUTTON_MESSAGE_FILE)

            logger.info("All data saved to disk successfully.")
            logger.info(f"Pricing state after _save_data_to_disk(): {pricing}")
        except Exception as e:
            logger.error(f"Error saving data to disk: {e}")
        finally:
            save_pending = False

# Ø¯Ø§Ù„Ø© Ø§Ù„Ø­ÙØ¸ Ø§Ù„Ù…Ø¤Ø¬Ù„
def schedule_save():
    global save_timer, save_pending
    if save_pending:
        logger.info("Save already pending, skipping new schedule.")
        return

    if save_timer is not None:
        save_timer.cancel()

    save_pending = True
    save_timer = threading.Timer(0.5, _save_data_to_disk)
    save_timer.start()
    logger.info("Data save scheduled with 0.5 sec delay.")


# ØªÙ‡ÙŠØ¦Ø© Ù…Ù„Ù Ø¹Ø¯Ø§Ø¯ Ø§Ù„ÙÙˆØ§ØªÙŠØ±
os.makedirs(DATA_DIR, exist_ok=True)
if not os.path.exists(COUNTER_FILE):
    with open(COUNTER_FILE, "w") as f:
        f.write("1")

def get_invoice_number():
    with open(COUNTER_FILE, "r") as f:
        current = int(f.read().strip())
    with open(COUNTER_FILE, "w") as f:
        f.write(str(current + 1))
    return current

# ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¹Ù†Ø¯ Ø¨Ø¯Ø¡ Ø§Ù„Ø¨ÙˆØª
load_data()

# Ø­Ø§Ù„Ø§Øª Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©
ASK_BUY, ASK_SELL, ASK_PLACES_COUNT = range(3) # Ø£Ø¶ÙÙ†Ø§ Ø­Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø­Ù„Ø§Øª

# Ø¬Ù„Ø¨ Ø§Ù„ØªÙˆÙƒÙ† ÙˆÙ…Ø¹Ø±Ù Ø§Ù„Ù…Ø§Ù„Ùƒ Ù…Ù† Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¨ÙŠØ¦Ø©
TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
OWNER_ID = int(os.getenv("OWNER_TELEGRAM_ID")) 
OWNER_PHONE_NUMBER = "+9647733921468" 

if TOKEN is None:
    raise ValueError("TELEGRAM_BOT_TOKEN environment variable not set.")
if OWNER_ID is None:
    raise ValueError("OWNER_TELEGRAM_ID environment variable not set.")

# Ø¯Ø§Ù„Ø© Ù„ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¹Ø´Ø±ÙŠØ©
def format_float(value):
    formatted = f"{value:g}"
    if formatted.endswith(".0"):
        return formatted[:-2]
    return formatted

# Ø¯Ø§Ù„Ø© Ù„Ø­Ø³Ø§Ø¨ Ù…Ø¨Ù„Øº Ø§Ù„Ø£Ø¬Ø±Ø© Ø§Ù„Ø¥Ø¶Ø§ÙÙŠ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø­Ù„Ø§Øª
def calculate_extra(places_count):
    if places_count <= 2:
        return 0
    elif places_count == 3:
        return 1
    elif places_count == 4:
        return 2
    elif places_count == 5:
        return 3
    elif places_count == 6:
        return 4
    elif places_count == 7:
        return 5
    elif places_count == 8:
        return 6
    elif places_count == 9:
        return 7
    elif places_count >= 10:
        return 8
    return 0

# Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ø­Ø°Ù Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ ÙÙŠ Ø§Ù„Ø®Ù„ÙÙŠØ©
async def delete_message_in_background(context: ContextTypes.DEFAULT_TYPE, chat_id: int, message_id: int):
    try:
        await asyncio.sleep(0.1) # Ø²ÙŠØ§Ø¯Ø© Ø§Ù„ØªØ£Ø®ÙŠØ± Ù„Ø¶Ù…Ø§Ù† Ø¸Ù‡ÙˆØ± Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
        await context.bot.delete_message(chat_id=chat_id, message_id=message_id)
        logger.info(f"Successfully deleted message {message_id} from chat {chat_id} in background.")
    except Exception as e:
        logger.warning(f"Could not delete message {message_id} from chat {chat_id} in background: {e}.")

# Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ø­ÙØ¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙÙŠ Ø§Ù„Ø®Ù„ÙÙŠØ©
async def save_data_in_background(context: ContextTypes.DEFAULT_TYPE):
    schedule_save()
    logger.info("Data save scheduled in background.")

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = str(update.message.from_user.id)
    logger.info(f"[{update.effective_chat.id}] /start command from user {user_id}. User data before clearing: {json.dumps(context.user_data.get(user_id, {}), indent=2)}")
    if user_id in context.user_data:
        context.user_data[user_id].pop("order_id", None)
        context.user_data[user_id].pop("product", None)
        context.user_data[user_id].pop("current_active_order_id", None)
        context.user_data[user_id].pop("messages_to_delete", None) 
        context.user_data[user_id].pop("buy_price", None) # Clear buy_price too
        logger.info(f"Cleared order-specific user_data for user {user_id} on /start command. User data after clearing: {json.dumps(context.user_data.get(user_id, {}), indent=2)}")
    
    await update.message.reply_text("Ø£Ù‡Ù„Ø§Ù‹ Ø¨Ùƒ ÙŠØ§ Ø£Ø¨Ø§ Ø§Ù„Ø£ÙƒØ¨Ø±! Ù„Ø¥Ø¹Ø¯Ø§Ø¯ Ø·Ù„Ø¨ÙŠØ©ØŒ Ø¯Ø² Ø§Ù„Ø·Ù„Ø¨ÙŠØ© ÙƒÙ„Ù‡Ø§ Ø¨Ø±Ø³Ø§Ù„Ø© ÙˆØ§Ø­Ø¯Ø©.\n\n*Ø§Ù„Ø³Ø·Ø± Ø§Ù„Ø£ÙˆÙ„:* Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø²Ø¨ÙˆÙ†.\n*Ø§Ù„Ø£Ø³Ø·Ø± Ø§Ù„Ø¨Ø§Ù‚ÙŠØ©:* ÙƒÙ„ Ù…Ù†ØªØ¬ Ø¨Ø³Ø·Ø± ÙˆØ§Ø­Ø¯.", parse_mode="Markdown")
    return ConversationHandler.END

async def receive_order(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        logger.info(f"[{update.effective_chat.id}] Processing order from: {update.effective_user.id} - Message ID: {update.message.message_id}. User data: {json.dumps(context.user_data.get(str(update.effective_user.id), {}), indent=2)}")
        await process_order(update, context, update.message)
        # Ù‡Ø°Ø§ ÙŠÙ†Ù‡ÙŠ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ø¨Ø¹Ø¯ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø·Ù„Ø¨ ÙƒØ±Ø³Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø©ØŒ
        # Ø¨Ø­ÙŠØ« Ù„Ø§ ÙŠØªØ¯Ø®Ù„ ÙÙŠ Ø­Ø§Ù„Ø© Ø§Ù„Ù€ "product_selected" Ø¥Ø°Ø§ ØªÙ… Ø§Ù„Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø²Ø±
        return ConversationHandler.END
    except Exception as e:
        logger.error(f"[{update.effective_chat.id}] Error in receive_order: {e}", exc_info=True)
        await update.message.reply_text("Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø·Ù„Ø¨. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ø£Ùˆ Ø¨Ø¯Ø¡ Ø·Ù„Ø¨ÙŠØ© Ø¬Ø¯ÙŠØ¯Ø©.")
        return ConversationHandler.END

async def edited_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        if not update.edited_message:
            return
        logger.info(f"[{update.effective_chat.id}] Processing edited order from: {update.effective_user.id} - Message ID: {update.edited_message.message_id}. User data: {json.dumps(context.user_data.get(str(update.effective_user.id), {}), indent=2)}")
        await process_order(update, context, update.edited_message, edited=True)
    except Exception as e:
        logger.error(f"[{update.effective_chat.id}] Error in edited_message: {e}", exc_info=True)
        await update.edited_message.reply_text("Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØªØ¹Ø¯ÙŠÙ„. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.")
        # No specific return for ConversationHandler here as it's not an entry point of a state

async def process_order(update, context, message, edited=False):
    user_id = str(message.from_user.id)
    lines = [line.strip() for line in message.text.strip().split('\n') if line.strip()]
    
    if len(lines) < 2:
        if not edited:
            await message.reply_text("Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ÙƒØªØ§Ø¨Ø© Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø²Ø¨ÙˆÙ† ÙÙŠ Ø§Ù„Ø³Ø·Ø± Ø§Ù„Ø£ÙˆÙ„ ÙˆØ§Ù„Ù…Ù†ØªØ¬Ø§Øª ÙÙŠ Ø§Ù„Ø£Ø³Ø·Ø± Ø§Ù„ØªØ§Ù„ÙŠØ©.")
        return

    title = lines[0]
    # ***** ØªØ¹Ø¯ÙŠÙ„: ØªÙ†Ø¸ÙŠÙ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª Ø¹Ù†Ø¯ Ø§Ù„Ø§Ø³ØªÙ„Ø§Ù… *****
    products = [p.strip() for p in lines[1:] if p.strip()]

    if not products:
        if not edited:
            await message.reply_text("Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¶Ø§ÙØ© Ù…Ù†ØªØ¬Ø§Øª Ø¨Ø¹Ø¯ Ø§Ù„Ø¹Ù†ÙˆØ§Ù†.")
        return

    order_id = None
    is_new_order = True 

    if edited:
        for oid, msg_info in last_button_message.items():
            if msg_info and msg_info.get("message_id") == message.message_id and str(msg_info.get("chat_id")) == str(message.chat_id):
                if oid in orders: 
                    order_id = oid
                    is_new_order = False
                    logger.info(f"Found existing order {order_id} based on message ID (edited message).")
                    break
                else:
                    logger.warning(f"Message ID {message.message_id} found in last_button_message but order {oid} is missing. Treating as new.")
                    order_id = None 
                    
    if not order_id: 
        order_id = str(uuid.uuid4())[:8]
        invoice_no = get_invoice_number()
        orders[order_id] = {"user_id": user_id, "title": title, "products": products, "places_count": 0} 
        pricing[order_id] = {p: {} for p in products}
        invoice_numbers[order_id] = invoice_no
        logger.info(f"Created new order {order_id} for user {user_id}.")
    else: 
        old_products = set(orders[order_id].get("products", []))
        new_products = set(products)
        
        orders[order_id]["title"] = title
        orders[order_id]["products"] = products

        for p in new_products:
            if p not in pricing.get(order_id, {}):
                pricing.setdefault(order_id, {})[p] = {}
        
        if order_id in pricing:
            for p in old_products - new_products:
                if p in pricing[order_id]:
                    del pricing[order_id][p]
                    logger.info(f"Removed pricing for product '{p}' from order {order_id}.")
        logger.info(f"Updated existing order {order_id}. Initiator: {user_id}.")
        
    context.application.create_task(save_data_in_background(context))
    
    if is_new_order:
        await message.reply_text(f"Ø§Ø³ØªÙ„Ù…Øª Ø§Ù„Ø·Ù„Ø¨ Ø¨Ø¹Ù†ÙˆØ§Ù†: *{title}* (Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª: {len(products)})", parse_mode="Markdown")
        await show_buttons(message.chat_id, context, user_id, order_id)
    else:
        await show_buttons(message.chat_id, context, user_id, order_id, confirmation_message="ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø·Ù„Ø¨. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ØªØ³Ø¹ÙŠØ± Ø£ÙŠ Ù…Ù†ØªØ¬Ø§Øª Ø¬Ø¯ÙŠØ¯Ø©.")
        
async def show_buttons(chat_id, context, user_id, order_id, confirmation_message=None):
    try:
        logger.info(f"[{chat_id}] show_buttons called for order {order_id}. User: {user_id}.")
        logger.info(f"[{chat_id}] Current pricing data for order {order_id} in show_buttons: {json.dumps(pricing.get(order_id), indent=2)}")

        if order_id not in orders:
            logger.warning(f"[{chat_id}] Attempted to show buttons for non-existent order_id: {order_id}")
            await context.bot.send_message(chat_id=chat_id, text="Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø§Ù„Ø·Ù„Ø¨ Ø§Ù„Ø°ÙŠ ØªØ­Ø§ÙˆÙ„ Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„ÙŠÙ‡ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ Ø£Ùˆ ØªÙ… Ø­Ø°ÙÙ‡. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¨Ø¯Ø¡ Ø·Ù„Ø¨ÙŠØ© Ø¬Ø¯ÙŠØ¯Ø©.")
            if user_id in context.user_data:
                context.user_data[user_id].pop("order_id", None)
                context.user_data[user_id].pop("product", None)
                context.user_data[user_id].pop("current_active_order_id", None)
                context.user_data[user_id].pop("messages_to_delete", None)
            return

        order = orders[order_id]
        
        completed_products = []
        pending_products = []
        
        for p in order["products"]:
            if p in pricing.get(order_id, {}) and 'buy' in pricing[order_id].get(p, {}) and 'sell' in pricing[order_id].get(p, {}):
                completed_products.append(p)
                logger.info(f"[{chat_id}] Product '{p}' in order {order_id} is completed.")
            else:
                pending_products.append(p)
                logger.info(f"[{chat_id}] Product '{p}' in order {order_id} is pending. Pricing state for this product: {json.dumps(pricing.get(order_id, {}).get(p, {}), indent=2)}")
        
        buttons_list = []
        for p in completed_products:
            buttons_list.append([InlineKeyboardButton(f"âœ… {p}", callback_data=f"{order_id}|{p}")])
        for p in pending_products:
            buttons_list.append([InlineKeyboardButton(p, callback_data=f"{order_id}|{p}")])
        
        markup = InlineKeyboardMarkup(buttons_list)
        
        message_text = ""
        if confirmation_message:
            message_text += f"{confirmation_message}\n\n"
        message_text += f"Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ù…Ù†ØªØ¬ Ù„ØªØ­Ø¯ÙŠØ¯ Ø³Ø¹Ø±Ù‡ Ù…Ù† *{order['title']}*:"

        msg_info = last_button_message.get(order_id)
        if msg_info:
            logger.info(f"[{chat_id}] Deleting old button message {msg_info['message_id']} for order {order_id} before sending new one.")
            context.application.create_task(delete_message_in_background(context, chat_id=msg_info["chat_id"], message_id=msg_info["message_id"]))
            # No del last_button_message[order_id] here, it's updated after new message is sent

        msg = await context.bot.send_message(
            chat_id=chat_id,
            text=message_text,
            reply_markup=markup,
            parse_mode="Markdown"
        )
        logger.info(f"[{chat_id}] Sent new button message {msg.message_id} for order {order_id}")
        last_button_message[order_id] = {"chat_id": chat_id, "message_id": msg.message_id}
        context.application.create_task(save_data_in_background(context))

        if user_id in context.user_data and 'messages_to_delete' in context.user_data[user_id]:
            logger.info(f"[{chat_id}] Scheduling deletion of {len(context.user_data[user_id].get('messages_to_delete', []))} old messages after showing new buttons for user {user_id}.")
            for msg_info in context.user_data[user_id]['messages_to_delete']:
                context.application.create_task(delete_message_in_background(context, chat_id=msg_info['chat_id'], message_id=msg_info['message_id']))
            context.user_data[user_id]['messages_to_delete'].clear()
    except Exception as e:
        logger.error(f"[{chat_id}] Error in show_buttons for order {order_id}: {e}", exc_info=True)
        await context.bot.send_message(chat_id=chat_id, text="Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¹Ø±Ø¶ Ø§Ù„Ø£Ø²Ø±Ø§Ø±. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¨Ø¯Ø¡ Ø·Ù„Ø¨ÙŠØ© Ø¬Ø¯ÙŠØ¯Ø©.")


async def product_selected(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        query = update.callback_query
        await query.answer()

        logger.info(f"[{query.message.chat_id}] Callback query received: {query.data} from user {query.from_user.id}. User data: {json.dumps(context.user_data.get(str(query.from_user.id), {}), indent=2)}")

        user_id = str(query.from_user.id)
        
        try:
            order_id, product = query.data.split("|", 1) 
            # ***** ØªØ¹Ø¯ÙŠÙ„: ØªÙ†Ø¸ÙŠÙ Ø§Ø³Ù… Ø§Ù„Ù…Ù†ØªØ¬ Ø§Ù„Ù‚Ø§Ø¯Ù… Ù…Ù† Ø§Ù„Ù€ callback_data Ø£ÙŠØ¶Ø§Ù‹ *****
            product = product.strip() 
        except ValueError as e:
            logger.error(f"[{query.message.chat_id}] Failed to parse callback_data for product selection: {query.data}. Error: {e}", exc_info=True)
            await query.message.reply_text("Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø²Ø±. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¨Ø¯Ø¡ Ø·Ù„Ø¨ÙŠØ© Ø¬Ø¯ÙŠØ¯Ø©.")
            return ConversationHandler.END

        if order_id not in orders or product not in orders[order_id].get("products", []):
            logger.warning(f"[{query.message.chat_id}] Order ID '{order_id}' not found or Product '{product}' not in products for order '{order_id}'.")
            await query.message.reply_text("Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø§Ù„Ø·Ù„Ø¨ Ø£Ùˆ Ø§Ù„Ù…Ù†ØªØ¬ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¨Ø¯Ø¡ Ø·Ù„Ø¨ÙŠØ© Ø¬Ø¯ÙŠØ¯Ø© Ø£Ùˆ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª.")
            if user_id in context.user_data:
                context.user_data[user_id].pop("order_id", None)
                context.user_data[user_id].pop("product", None)
                context.user_data[user_id].pop("current_active_order_id", None)
                context.user_data[user_id].pop("messages_to_delete", None)
            return ConversationHandler.END
        
        context.user_data.setdefault(user_id, {}).update({"order_id": order_id, "product": product})
        logger.info(f"[{query.message.chat_id}] User {user_id} selected product '{product}' for order '{order_id}'. User data updated: {json.dumps(context.user_data.get(user_id), indent=2)}")
        
        if 'messages_to_delete' not in context.user_data[user_id]:
            context.user_data[user_id]['messages_to_delete'] = [] 

        if query.message:
            context.user_data[user_id]['messages_to_delete'].append({
                'chat_id': query.message.chat_id,
                'message_id': query.message.message_id
            })
            logger.info(f"[{query.message.chat_id}] Added button message {query.message.message_id} to delete queue for order {order_id}.")
            try:
                await context.bot.edit_message_reply_markup(
                    chat_id=query.message.chat_id,
                    message_id=query.message.message_id,
                    reply_markup=None 
                )
            except Exception as e:
                logger.warning(f"[{query.message.chat_id}] Could not clear buttons from message {query.message.message_id} directly: {e}. Proceeding.")


        msg = await query.message.reply_text(f"ØªÙ…Ø§Ù…ØŒ ÙƒÙ… Ø³Ø¹Ø± Ø´Ø±Ø§Ø¡ *'{product}'*ØŸ", parse_mode="Markdown")
        context.user_data[user_id]['messages_to_delete'].append({'chat_id': msg.chat_id, 'message_id': msg.message_id})
        logger.info(f"[{query.message.chat_id}] Asking for buy price for '{product}'. Next state: ASK_BUY. Current user_data: {json.dumps(context.user_data.get(user_id), indent=2)}")
        
        return ASK_BUY
    except Exception as e:
        logger.error(f"[{update.effective_chat.id}] Error in product_selected: {e}", exc_info=True)
        await update.callback_query.message.reply_text("Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ù†ØªØ¬. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¨Ø¯Ø¡ Ø·Ù„Ø¨ÙŠØ© Ø¬Ø¯ÙŠØ¯Ø©.")
        return ConversationHandler.END
    
async def receive_buy_price(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        user_id = str(update.message.from_user.id)
        logger.info(f"[{update.effective_chat.id}] Received message for buy price from user {user_id}: '{update.message.text}'. User data at start of receive_buy_price: {json.dumps(context.user_data.get(user_id), indent=2)}")

        context.user_data.setdefault(user_id, {})
        if 'messages_to_delete' not in context.user_data[user_id]:
            context.user_data[user_id]['messages_to_delete'] = []
        
        context.user_data[user_id]['messages_to_delete'].append({
            'chat_id': update.message.chat_id,
            'message_id': update.message.message_id
        })

        data = context.user_data.get(user_id)
        if not data or "order_id" not in data or "product" not in data:
            logger.error(f"[{update.effective_chat.id}] Buy price: Missing order_id or product in user_data for user {user_id}. User data: {json.dumps(data, indent=2)}")
            msg_error = await update.message.reply_text("Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù„Ù… Ø£ØªÙ…ÙƒÙ† Ù…Ù† ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø·Ù„Ø¨ÙŠØ© Ø£Ùˆ Ø§Ù„Ù…Ù†ØªØ¬ Ù„ØªØ³Ø¹ÙŠØ±Ù‡. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù†ØªØ¬ Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø£ÙˆÙ„Ø§Ù‹ Ù„ØªØ­Ø¯ÙŠØ¯ Ø³Ø¹Ø±Ù‡ØŒ Ø£Ùˆ Ø§Ø¨Ø¯Ø£ Ø·Ù„Ø¨ÙŠØ© Ø¬Ø¯ÙŠØ¯Ø©.", parse_mode="Markdown")
            context.user_data[user_id]['messages_to_delete'].append({
                'chat_id': msg_error.chat_id, 
                'message_id': msg_error.message_id
            })
            return ConversationHandler.END
        
        order_id = data["order_id"]
        product = data["product"]
        
        if order_id not in orders or product not in orders[order_id].get("products", []):
            logger.warning(f"[{update.effective_chat.id}] Buy price: Order ID '{order_id}' not found or Product '{product}' not in products for order '{order_id}'.")
            msg_error = await update.message.reply_text("Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø§Ù„Ø·Ù„Ø¨ÙŠØ© Ø£Ùˆ Ø§Ù„Ù…Ù†ØªØ¬ Ù„Ù… ÙŠØ¹Ø¯ Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¨Ø¯Ø¡ Ø·Ù„Ø¨ÙŠØ© Ø¬Ø¯ÙŠØ¯Ø© Ø£Ùˆ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª.")
            context.user_data[user_id]['messages_to_delete'].append({
                'chat_id': msg_error.chat_id, 
                'message_id': msg_error.message_id
            })
            return ConversationHandler.END
        
        # Regex to accept integers or floats
        if not filters.Regex(r"^\d+(\.\d+)?$").check_update(update):
            logger.warning(f"[{update.effective_chat.id}] Buy price: Non-numeric input from user {user_id}: '{update.message.text}'")
            msg_error = await update.message.reply_text("Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ *Ø±Ù‚Ù…* ØµØ­ÙŠØ­ Ù„Ø³Ø¹Ø± Ø§Ù„Ø´Ø±Ø§Ø¡.")
            context.user_data[user_id]['messages_to_delete'].append({
                'chat_id': msg_error.chat_id, 
                'message_id': msg_error.message_id
            })
            return ASK_BUY 

        try:
            price = float(update.message.text.strip())
            if price < 0:
                logger.warning(f"[{update.effective_chat.id}] Buy price: Negative price from user {user_id}: '{update.message.text}'")
                msg_error = await update.message.reply_text("Ø§Ù„Ø³Ø¹Ø± ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ù…ÙˆØ¬Ø¨Ø§Ù‹")
                context.user_data[user_id]['messages_to_delete'].append({
                    'chat_id': msg_error.chat_id, 
                    'message_id': msg_error.message_id
                })
                return ASK_BUY
        except ValueError as e: 
            logger.error(f"[{update.effective_chat.id}] Buy price: ValueError for user {user_id} with input '{update.message.text}': {e}", exc_info=True)
            msg_error = await update.message.reply_text("Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… ØµØ­ÙŠØ­")
            context.user_data[user_id]['messages_to_delete'].append({
                    'chat_id': msg_error.chat_id, 
                    'message_id': msg_error.message_id
                })
            return ASK_BUY
        
        context.user_data[user_id]["buy_price"] = price 
        logger.info(f"[{update.effective_chat.id}] Buy price '{price}' stored in user_data for product '{product}'. User data after storing buy_price: {json.dumps(context.user_data.get(user_id), indent=2)}")

        msg = await update.message.reply_text(f"Ø´ÙƒØ±Ø§Ù‹. ÙˆÙ‡Ø³Ù‡ØŒ Ø¨ÙŠØ´ Ø±Ø§Ø­ ØªØ¨ÙŠØ¹ *'{product}'*ØŸ", parse_mode="Markdown")
        context.user_data[user_id]['messages_to_delete'].append({'chat_id': msg.chat_id, 'message_id': msg.message_id})
        logger.info(f"[{update.effective_chat.id}] Asking for sell price for '{product}'. Next state: ASK_SELL. Current user_data: {json.dumps(context.user_data.get(user_id), indent=2)}")
        
        return ASK_SELL
    except Exception as e:
        logger.error(f"[{update.effective_chat.id}] Error in receive_buy_price: {e}", exc_info=True)
        await update.message.reply_text("Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø³Ø¹Ø± Ø§Ù„Ø´Ø±Ø§Ø¡. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¨Ø¯Ø¡ Ø·Ù„Ø¨ÙŠØ© Ø¬Ø¯ÙŠØ¯Ø©.")
        return ConversationHandler.END


async def receive_sell_price(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        user_id = str(update.message.from_user.id)
        logger.info(f"[{update.effective_chat.id}] Received message for sell price from user {user_id}: '{update.message.text}'. User data at start of receive_sell_price: {json.dumps(context.user_data.get(user_id), indent=2)}")

        context.user_data.setdefault(user_id, {})
        if 'messages_to_delete' not in context.user_data[user_id]:
            context.user_data[user_id]['messages_to_delete'] = []
        context.user_data[user_id]['messages_to_delete'].append({'chat_id': update.message.chat_id, 'message_id': update.message.message_id})

        data = context.user_data.get(user_id)
        if not data or "order_id" not in data or "product" not in data or "buy_price" not in data: # Added buy_price check
            logger.error(f"[{update.effective_chat.id}] Sell price: Missing order_id, product, or buy_price in user_data for user {user_id}. User data: {json.dumps(data, indent=2)}")
            msg_error = await update.message.reply_text("Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù„Ù… Ø£ØªÙ…ÙƒÙ† Ù…Ù† ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø·Ù„Ø¨ÙŠØ© Ø£Ùˆ Ø§Ù„Ù…Ù†ØªØ¬ Ù„ØªØ³Ø¹ÙŠØ±Ù‡. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù†ØªØ¬ Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø£ÙˆÙ„Ø§Ù‹ Ù„ØªØ­Ø¯ÙŠØ¯ Ø³Ø¹Ø±Ù‡ØŒ Ø£Ùˆ Ø§Ø¨Ø¯Ø£ Ø·Ù„Ø¨ÙŠØ© Ø¬Ø¯ÙŠØ¯Ø©.", parse_mode="Markdown")
            context.user_data[user_id]['messages_to_delete'].append({
                'chat_id': msg_error.chat_id, 
                'message_id': msg_error.message_id
            })
            return ConversationHandler.END
        
        order_id, product, buy_price_from_user_data = data["order_id"], data["product"], data["buy_price"]
        
        if order_id not in orders or product not in orders[order_id].get("products", []):
            logger.warning(f"[{update.effective_chat.id}] Sell price: Order ID '{order_id}' not found or Product '{product}' not in products for order '{order_id}'.")
            msg_error = await update.message.reply_text("Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø§Ù„Ø·Ù„Ø¨ÙŠØ© Ø£Ùˆ Ø§Ù„Ù…Ù†ØªØ¬ Ù„Ù… ÙŠØ¹Ø¯ Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¨Ø¯Ø¡ Ø·Ù„Ø¨ÙŠØ© Ø¬Ø¯ÙŠØ¯Ø©.")
            context.user_data[user_id]['messages_to_delete'].append({
                'chat_id': msg_error.chat_id, 
                'message_id': msg_error.message_id
            })
            return ConversationHandler.END

        # Regex to accept integers or floats
        if not filters.Regex(r"^\d+(\.\d+)?$").check_update(update): 
            logger.warning(f"[{update.effective_chat.id}] Sell price: Non-numeric input from user {user_id}: '{update.message.text}'")
            msg_error = await update.message.reply_text("Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ *Ø±Ù‚Ù…* ØµØ­ÙŠØ­ Ù„Ø³Ø¹Ø± Ø§Ù„Ø¨ÙŠØ¹.")
            context.user_data[user_id]['messages_to_delete'].append({'chat_id': msg_error.chat_id, 'message_id': msg_error.message_id})
            return ASK_SELL 

        try:
            sell_price = float(update.message.text.strip())
            if sell_price < 0:
                logger.warning(f"[{update.effective_chat.id}] Sell price: Negative price from user {user_id}: '{update.message.text}'")
                msg_error = await update.message.reply_text("Ø³Ø¹Ø± Ø§Ù„Ø¨ÙŠØ¹ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø±Ù‚Ù…Ø§Ù‹ Ø¥ÙŠØ¬Ø§Ø¨ÙŠØ§Ù‹. Ø¨ÙŠØ´ Ø±Ø§Ø­ ØªØ¨ÙŠØ¹ Ø¨Ø§Ù„Ø¶Ø¨Ø·ØŸ")
                context.user_data[user_id]['messages_to_delete'].append({'chat_id': msg_error.chat_id, 'message_id': msg_error.message_id})
                return ASK_SELL 
        except ValueError as e:
            logger.error(f"[{update.effective_chat.id}] Sell price: ValueError for user {user_id} with input '{update.message.text}': {e}", exc_info=True)
            msg_error = await update.message.reply_text("Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… ØµØ­ÙŠØ­ Ù„Ø³Ø¹Ø± Ø§Ù„Ø¨ÙŠØ¹. Ø¨ÙŠØ´ Ø­ØªØ¨ÙŠØ¹ØŸ")
            context.user_data[user_id]['messages_to_delete'].append({'chat_id': msg_error.chat_id, 'message_id': msg_error.message_id})
            return ASK_SELL 
        
        pricing.setdefault(order_id, {}).setdefault(product, {})["buy"] = buy_price_from_user_data
        pricing[order_id][product]["sell"] = sell_price
        
        logger.info(f"[{update.effective_chat.id}] Pricing for order '{order_id}' and product '{product}' AFTER SAVE: {json.dumps(pricing.get(order_id, {}).get(product), indent=2)}")
        context.application.create_task(save_data_in_background(context))
        logger.info(f"[{update.effective_chat.id}] Sell price for '{product}' in order '{order_id}' saved. Current user_data: {json.dumps(context.user_data.get(user_id), indent=2)}. Updated pricing for order {order_id}: {json.dumps(pricing.get(order_id), indent=2)}")

        order = orders[order_id]
        all_priced = True
        for p in order["products"]:
            if p not in pricing.get(order_id, {}) or "buy" not in pricing[order_id].get(p, {}) or "sell" not in pricing[order_id].get(p, {}):
                all_priced = False
                break
                
        if all_priced:
            # Ù‡Ù†Ø§ Ù†Ù†Ù‡ÙŠ ConversationHandler Ø§Ù„Ø®Ø§Øµ Ø¨Ø§Ù„Ø£Ø³Ø¹Ø§Ø±
            # ÙˆÙ†Ù†ØªÙ‚Ù„ Ø¥Ù„Ù‰ ConversationHandler Ø§Ù„Ø®Ø§Øµ Ø¨Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø­Ù„Ø§Øª
            context.user_data[user_id]["current_active_order_id"] = order_id
            logger.info(f"[{update.effective_chat.id}] All products priced for order {order_id}. Requesting places count. Transitioning to ASK_PLACES_COUNT.")
            await request_places_count_standalone(update.effective_chat.id, context, user_id, order_id)
            return ConversationHandler.END # Ù†Ù†Ù‡ÙŠ Ù…Ø­Ø§Ø¯Ø«Ø© ØªØ³Ø¹ÙŠØ± Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª
        else:
            confirmation_msg = f"ØªÙ… Ø­ÙØ¸ Ø§Ù„Ø³Ø¹Ø± Ù„Ù€ *'{product}'*."
            logger.info(f"[{update.effective_chat.id}] Price saved for '{product}' in order {order_id}. Showing updated buttons with confirmation. User {user_id} can select next product. Staying in conversation.")
            await show_buttons(update.effective_chat.id, context, user_id, order_id, confirmation_message=confirmation_msg)
            return ConversationHandler.END 
    except Exception as e:
        logger.error(f"[{update.effective_chat.id}] Error in receive_sell_price: {e}", exc_info=True)
        await update.message.reply_text("Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø³Ø¹Ø± Ø§Ù„Ø¨ÙŠØ¹. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¨Ø¯Ø¡ Ø·Ù„Ø¨ÙŠØ© Ø¬Ø¯ÙŠØ¯Ø©.")
        return ConversationHandler.END

async def request_places_count_standalone(chat_id, context: ContextTypes.DEFAULT_TYPE, user_id: str, order_id: str):
    try:
        logger.info(f"[{chat_id}] request_places_count_standalone called for order {order_id} from user {user_id}. User data: {json.dumps(context.user_data.get(user_id), indent=2)}")
        context.user_data.setdefault(user_id, {})["current_active_order_id"] = order_id

        buttons = []
        emojis = ['1ï¸âƒ£', '2ï¸âƒ£', '3ï¸âƒ£', '4ï¸âƒ£', '5ï¸âƒ£', '6ï¸âƒ£', '7ï¸âƒ£', '8ï¸âƒ£', '9ï¸âƒ£', 'ğŸ”Ÿ']
        for i in range(1, 11):
            buttons.append(InlineKeyboardButton(emojis[i-1], callback_data=f"places_data_{order_id}_{i}"))
        
        keyboard = [buttons[i:i + 5] for i in range(0, len(buttons), 5)]
        reply_markup = InlineKeyboardMarkup(keyboard)

        msg_places = await context.bot.send_message(
            chat_id=chat_id,
            text="ØªÙ…Ø§Ù…ØŒ ÙƒÙ„ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª ØªØ³Ø¹Ù‘Ø±Øª. Ù‡Ø³Ù‡ØŒ ÙƒÙ… Ù…Ø­Ù„ ÙƒÙ„ÙØªÙƒ Ø§Ù„Ø·Ù„Ø¨ÙŠØ©ØŸ (Ø§Ø®ØªØ± Ù…Ù† Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø£Ùˆ Ø§ÙƒØªØ¨ Ø§Ù„Ø±Ù‚Ù…)", 
            reply_markup=reply_markup
        )
        
        # ØªØ®Ø²ÙŠÙ† Ù…Ø¹Ø±Ù Ø§Ù„Ø±Ø³Ø§Ù„Ø© ÙÙŠ user_data Ù„Ù„Ø±Ø¬ÙˆØ¹ Ø¥Ù„ÙŠÙ‡Ø§ Ù„Ø§Ø­Ù‚Ø§Ù‹
        context.user_data[user_id]['places_count_message'] = {
            'chat_id': msg_places.chat_id,
            'message_id': msg_places.message_id
        }

        if user_id in context.user_data and 'messages_to_delete' in context.user_data[user_id]:
            logger.info(f"[{chat_id}] Scheduling deletion of {len(context.user_data[user_id].get('messages_to_delete', []))} old messages after showing places buttons for user {user_id}.")
            for msg_info in context.user_data[user_id]['messages_to_delete']:
                context.application.create_task(delete_message_in_background(context, chat_id=msg_info['chat_id'], message_id=msg_info['message_id']))
            context.user_data[user_id]['messages_to_delete'].clear()
        
        # Ù…Ù‡Ù… Ø¬Ø¯Ø§Ù‹: Ù‡Ù†Ø§ Ù„Ø§ Ù†Ø±Ø¬Ø¹ ASK_PLACES_COUNT. Ù‡Ø°Ø§ ÙŠØªÙ… Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹Ù‡ Ø¨ÙˆØ§Ø³Ø·Ø© ConversationHandler Ø§Ù„Ø®Ø§Øµ Ø¨Ù‡.
        # Ù‡Ø°Ù‡ Ø§Ù„Ø¯Ø§Ù„Ø© ÙÙ‚Ø· ØªØ·Ù„Ø¨ Ù…Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¥Ø¯Ø®Ø§Ù„ Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø­Ù„Ø§Øª.
        # Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„ÙØ¹Ù„ÙŠ (Ù†Øµ Ø£Ùˆ Ø²Ø±) Ø³ÙŠØªÙ… Ø§Ù„ØªÙ‚Ø§Ø·Ù‡ Ø¨ÙˆØ§Ø³Ø·Ø© ConversationHandler Ø§Ù„Ù…Ù†Ø§Ø³Ø¨.
    except Exception as e:
        logger.error(f"[{chat_id}] Error in request_places_count_standalone: {e}", exc_info=True)
        await context.bot.send_message(chat_id=chat_id, text="Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø·Ù„Ø¨ Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø­Ù„Ø§Øª. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¨Ø¯Ø¡ Ø·Ù„Ø¨ÙŠØ© Ø¬Ø¯ÙŠØ¯Ø©.")
        
async def handle_places_count_data(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        global daily_profit
        
        places = None
        chat_id = update.effective_chat.id
        user_id = str(update.effective_user.id) 
        logger.info(f"[{chat_id}] handle_places_count_data triggered by user {user_id}. Update type: {'CallbackQuery' if update.callback_query else 'Message'}. User data: {json.dumps(context.user_data.get(user_id), indent=2)}")

        context.user_data.setdefault(user_id, {})
        if 'messages_to_delete' not in context.user_data[user_id]:
            context.user_data[user_id]['messages_to_delete'] = []

        order_id_to_process = None 

        if update.callback_query:
            query = update.callback_query
            logger.info(f"[{chat_id}] Places count callback query received: {query.data}")
            await query.answer()
            
            try:
                parts = query.data.split('_')
                if len(parts) == 4 and parts[0] == "places" and parts[1] == "data":
                    order_id_to_process = parts[2] 
                    
                    if order_id_to_process not in orders:
                        logger.error(f"[{chat_id}] Order ID '{order_id_to_process}' from callback data not found in global orders.")
                        await context.bot.send_message(chat_id=chat_id, text="Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø§Ù„Ø·Ù„Ø¨ÙŠØ© Ø§Ù„Ù„ÙŠ Ø­Ø§ÙˆÙ„ ØªØ®ØªØ§Ø± Ø¹Ø¯Ø¯ Ù…Ø­Ù„Ø§ØªÙ‡Ø§ Ù…Ø§ Ù…ÙˆØ¬ÙˆØ¯Ø© Ø¹Ù†Ø¯ÙŠ. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¨Ø¯Ø¡ Ø·Ù„Ø¨ÙŠØ© Ø¬Ø¯ÙŠØ¯Ø©.")
                        if user_id in context.user_data and "current_active_order_id" in context.user_data[user_id]:
                            del context.user_data[user_id]["current_active_order_id"]
                        return ConversationHandler.END 

                    places = int(parts[3])
                    if query.message:
                        try:
                            # Ø­Ø°Ù Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø¨Ø¹Ø¯ Ø§Ù„Ø§Ø®ØªÙŠØ§Ø±
                            await context.bot.delete_message(chat_id=query.message.chat_id, message_id=query.message.message_id)
                        except Exception as e:
                            logger.warning(f"[{chat_id}] Could not delete places message {query.message.message_id} directly: {e}. Proceeding.")

                else:
                    raise ValueError(f"Unexpected callback_data format for places count: {query.data}")
            except (ValueError, IndexError) as e:
                logger.error(f"[{chat_id}] Failed to parse places count from callback data '{query.data}': {e}", exc_info=True)
                await context.bot.send_message(chat_id=chat_id, text="Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø²Ø±. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.")
                return ConversationHandler.END 
        
        elif update.message: 
            context.user_data[user_id]['messages_to_delete'].append({'chat_id': update.message.chat_id, 'message_id': update.message.message_id})
            logger.info(f"[{chat_id}] Received text message for places count from user {user_id}: '{update.message.text}'")
            
            order_id_to_process = context.user_data[user_id].get("current_active_order_id")

            if not order_id_to_process or order_id_to_process not in orders:
                 logger.warning(f"[{chat_id}] Places count text input: No current active order for user {user_id} or order {order_id_to_process} is invalid.")
                 msg_error = await context.bot.send_message(chat_id=chat_id, text="Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù…Ø§ÙƒÙˆ Ø·Ù„Ø¨ÙŠØ© Ø­Ø§Ù„ÙŠØ© Ù…Ù†ØªØ¸Ø± Ø¹Ø¯Ø¯ Ù…Ø­Ù„Ø§ØªÙ‡Ø§ Ø£Ùˆ Ø§Ù„Ø·Ù„Ø¨ÙŠØ© Ù‚Ø¯ÙŠÙ…Ø© Ø¬Ø¯Ø§Ù‹. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ù„ØªØ­Ø¯ÙŠØ¯ Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø­Ù„Ø§ØªØŒ Ø£Ùˆ Ø¨Ø¯Ø¡ Ø·Ù„Ø¨ÙŠØ© Ø¬Ø¯ÙŠØ¯Ø©.", parse_mode="Markdown")
                 context.user_data[user_id]['messages_to_delete'].append({'chat_id': msg_error.chat_id, 'message_id': msg_error.message_id})
                 if user_id in context.user_data and "current_active_order_id" in context.user_data[user_id]:
                     del context.user_data[user_id]["current_active_order_id"]
                 return ConversationHandler.END 

            if not update.message.text.strip().isdigit(): 
                logger.warning(f"[{chat_id}] Places count text input: Non-integer input from user {user_id}: '{update.message.text}'")
                msg_error = await context.bot.send_message(chat_id=chat_id, text="Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ *Ø±Ù‚Ù… ØµØ­ÙŠØ­* Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø­Ù„Ø§Øª.")
                context.user_data[user_id]['messages_to_delete'].append({'chat_id': msg_error.chat_id, 'message_id': msg_error.message_id})
                return ASK_PLACES_COUNT 
            
            try:
                places = int(update.message.text.strip())
                if places < 0:
                    logger.warning(f"[{chat_id}] Places count text input: Negative value from user {user_id}: '{update.message.text}'")
                    msg_error = await context.bot.send_message(chat_id=chat_id, text="Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø­Ù„Ø§Øª ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø±Ù‚Ù…Ø§Ù‹ Ù…ÙˆØ¬Ø¨Ø§Ù‹. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø­Ù„Ø§Øª Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­.")
                    context.user_data[user_id]['messages_to_delete'].append({'chat_id': msg_error.chat_id, 'message_id': msg_error.message_id})
                    return ASK_PLACES_COUNT 
            except ValueError as e: 
                logger.error(f"[{chat_id}] Places count text input: ValueError for user {user_id} with input '{update.message.text}': {e}", exc_info=True)
                msg_error = await context.bot.send_message(chat_id=chat_id, text="Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø¹Ø¯Ø¯ ØµØ­ÙŠØ­ Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø­Ù„Ø§Øª.")
                context.user_data[user_id]['messages_to_delete'].append({'chat_id': msg_error.chat_id, 'message_id': msg_error.message_id})
                return ASK_PLACES_COUNT 
        
        if places is None or order_id_to_process is None:
            logger.warning(f"[{chat_id}] handle_places_count_data: No valid places count or order ID to process.")
            await context.bot.send_message(chat_id=chat_id, text="Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù„Ù… Ø£ØªÙ…ÙƒÙ† Ù…Ù† ÙÙ‡Ù… Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø­Ù„Ø§Øª Ø£Ùˆ Ø§Ù„Ø·Ù„Ø¨ÙŠØ©. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… ØµØ­ÙŠØ­ Ø£Ùˆ Ø§Ù„Ø¨Ø¯Ø¡ Ø¨Ø·Ù„Ø¨ÙŠØ© Ø¬Ø¯ÙŠØ¯Ø©.")
            if user_id in context.user_data and "current_active_order_id" in context.user_data[user_id]:
                del context.user_data[user_id]["current_active_order_id"]
            return ConversationHandler.END 

        # Ø­Ø°Ù Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø®Ø§ØµØ© Ø¨Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø­Ù„Ø§Øª Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù…ÙˆØ¬ÙˆØ¯Ø© ÙˆÙ„Ù… ÙŠØªÙ… Ø­Ø°ÙÙ‡Ø§ Ø¹Ù† Ø·Ø±ÙŠÙ‚ Ø§Ù„Ù€ callback
        if 'places_count_message' in context.user_data[user_id]:
            msg_info = context.user_data[user_id]['places_count_message']
            try:
                await context.bot.delete_message(chat_id=msg_info['chat_id'], message_id=msg_info['message_id'])
            except Exception as e:
                logger.warning(f"[{chat_id}] Could not delete places count message: {e}")
            del context.user_data[user_id]['places_count_message']

        orders[order_id_to_process]["places_count"] = places
        context.application.create_task(save_data_in_background(context))
        logger.info(f"[{chat_id}] Places count {places} saved for order {order_id_to_process}. Current user_data: {json.dumps(context.user_data.get(user_id), indent=2)}")

        if user_id in context.user_data and 'messages_to_delete' in context.user_data[user_id]:
            logger.info(f"[{chat_id}] Scheduling deletion of {len(context.user_data[user_id].get('messages_to_delete', []))} old messages after showing final options for user {user_id}.")
            for msg_info in context.user_data[user_id]['messages_to_delete']:
                context.application.create_task(delete_message_in_background(context, chat_id=msg_info['chat_id'], message_id=msg_info['message_id']))
            context.user_data[user_id]['messages_to_delete'].clear()
        
        await show_final_options(chat_id, context, user_id, order_id_to_process, message_prefix="ØªÙ… ØªØ­Ø¯ÙŠØ« Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø­Ù„Ø§Øª Ø¨Ù†Ø¬Ø§Ø­.")
        
        if user_id in context.user_data and "current_active_order_id" in context.user_data[user_id]:
            del context.user_data[user_id]["current_active_order_id"]
            logger.info(f"[{chat_id}] Cleared current_active_order_id for user {user_id} after processing places count.")

        return ConversationHandler.END 
    except Exception as e:
        logger.error(f"[{chat_id}] Error in handle_places_count_data: {e}", exc_info=True)
        await context.bot.send_message(chat_id=chat_id, text="Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø­Ù„Ø§Øª. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¨Ø¯Ø¡ Ø·Ù„Ø¨ÙŠØ© Ø¬Ø¯ÙŠØ¯Ø©.")
        return ConversationHandler.END
        
async def show_final_options(chat_id, context, user_id, order_id, message_prefix=None):
    try:
        global daily_profit
        logger.info(f"[{chat_id}] Showing final options for order {order_id} to user {user_id}. User data: {json.dumps(context.user_data.get(user_id), indent=2)}")
        
        if order_id not in orders:
            logger.warning(f"[{chat_id}] Attempted to show final options for non-existent order_id: {order_id}")
            await context.bot.send_message(chat_id=chat_id, text="Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø§Ù„Ø·Ù„Ø¨ Ø§Ù„Ø°ÙŠ ØªØ­Ø§ÙˆÙ„ Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„ÙŠÙ‡ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ Ø£Ùˆ ØªÙ… Ø­Ø°ÙÙ‡. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¨Ø¯Ø¡ Ø·Ù„Ø¨ÙŠØ© Ø¬Ø¯ÙŠØ¯Ø©.")
            if user_id in context.user_data:
                context.user_data[user_id].pop("order_id", None)
                context.user_data[user_id].pop("product", None)
                context.user_data[user_id].pop("current_active_order_id", None)
                context.user_data[user_id].pop("messages_to_delete", None)
            return

        order = orders[order_id]
        invoice = invoice_numbers.get(order_id, "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ")
        
        total_buy = 0.0
        total_sell = 0.0
        for p in order["products"]:
            if p in pricing.get(order_id, {}) and "buy" in pricing[order_id].get(p, {}) and "sell" in pricing[order_id].get(p, {}):
                total_buy += pricing[order_id][p]["buy"]
                total_sell += pricing[order_id][p]["sell"]

        net_profit = total_sell - total_buy
        
        current_places = orders[order_id].get("places_count", 0) 
        extra_cost = calculate_extra(current_places)
        final_total = total_sell + extra_cost

        # Ø§Ù„Ø£Ø±Ø¨Ø§Ø­ Ù„Ø§ ØªØ¶Ø§Ù Ø¥Ù„Ø§ Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© Ø¹Ù†Ø¯ Ø§ÙƒØªÙ…Ø§Ù„ Ø§Ù„Ø·Ù„Ø¨ Ù„Ø£ÙˆÙ„ Ù…Ø±Ø©.
        # ÙŠØ¬Ø¨ Ø£Ù† Ù†ØªØ£ÙƒØ¯ Ø£Ù†Ù†Ø§ Ù„Ø§ Ù†Ø¶ÙŠÙ Ø§Ù„Ø±Ø¨Ø­ Ø¥Ø°Ø§ ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø·Ù„Ø¨ ÙÙ‚Ø·.
        # Ø­Ø§Ù„ÙŠØ§ØŒ Ø¥Ø°Ø§ ØªÙ… Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ù‡Ø°Ù‡ Ø§Ù„Ø¯Ø§Ù„Ø© Ø£ÙƒØ«Ø± Ù…Ù† Ù…Ø±Ø© Ù„Ù†ÙØ³ Ø§Ù„Ø·Ù„Ø¨ØŒ Ø³ÙŠØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø±Ø¨Ø­ ÙÙŠ ÙƒÙ„ Ù…Ø±Ø©.
        # Ù„Ù„ØªØ¨Ø³ÙŠØ·ØŒ Ù„Ù† Ù†ØºÙŠØ± Ø³Ù„ÙˆÙƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø±Ø¨Ø­ Ø­Ø§Ù„ÙŠØ§Ù‹ØŒ Ù„ÙƒÙ† ÙŠØ¬Ø¨ Ù…Ù„Ø§Ø­Ø¸Ø© Ø°Ù„Ùƒ.
        logger.info(f"[{chat_id}] Daily profit before addition for order {order_id}: {daily_profit}")
        daily_profit += net_profit
        logger.info(f"[{chat_id}] Daily profit after adding {net_profit} for order {order_id}: {daily_profit}")
        context.application.create_task(save_data_in_background(context))

        customer_invoice_lines = []
        customer_invoice_lines.append(f"**Ø£Ø¨Ùˆ Ø§Ù„Ø£ÙƒØ¨Ø± Ù„Ù„ØªÙˆØµÙŠÙ„**") 
        customer_invoice_lines.append(f"Ø±Ù‚Ù… Ø§Ù„ÙØ§ØªÙˆØ±Ø©: {invoice}")
        customer_invoice_lines.append(f"Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø²Ø¨ÙˆÙ†: {order['title']}")
        customer_invoice_lines.append(f"\n*Ø§Ù„Ù…ÙˆØ§Ø¯:*") 
        
        running_total_for_customer = 0.0
        for p in order["products"]:
            if p in pricing.get(order_id, {}) and "sell" in pricing[order_id].get(p, {}):
                sell = pricing[order_id][p]["sell"]
                running_total_for_customer += sell
                customer_invoice_lines.append(f"{p} - {format_float(sell)} = {format_float(running_total_for_customer)}")
            else:
                customer_invoice_lines.append(f"{p} - (Ù„Ù… ÙŠØªÙ… ØªØ³Ø¹ÙŠØ±Ù‡)")
        
        customer_invoice_lines.append(f"ÙƒÙ„ÙØ© ØªØ¬Ù‡ÙŠØ² Ù…Ù† - {current_places} Ù…Ø­Ù„Ø§Øª {format_float(extra_cost)} = {format_float(final_total)}")
        customer_invoice_lines.append(f"\n*Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹ Ø§Ù„ÙƒÙ„ÙŠ:* {format_float(final_total)} (Ù…Ø¹ Ø§Ø­ØªØ³Ø§Ø¨ Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø­Ù„Ø§Øª)") 
        
        customer_final_text = "\n".join(customer_invoice_lines)

        try:
            await context.bot.send_message(
                chat_id=chat_id,
                text=customer_final_text,
                parse_mode="Markdown"
            )
            logger.info(f"[{chat_id}] Customer invoice sent as a separate message for order {order_id}.")
        except Exception as e:
            logger.error(f"[{chat_id}] Could not send customer invoice as separate message to chat {chat_id}: {e}", exc_info=True)
            await context.bot.send_message(chat_id=chat_id, text="Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù„Ù… Ø£ØªÙ…ÙƒÙ† Ù…Ù† Ø¥Ø±Ø³Ø§Ù„ ÙØ§ØªÙˆØ±Ø© Ø§Ù„Ø²Ø¨ÙˆÙ†. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.")

        keyboard = [
            [InlineKeyboardButton("1ï¸âƒ£ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø£Ø³Ø¹Ø§Ø±", callback_data=f"edit_prices_{order_id}")],
            [InlineKeyboardButton("3ï¸âƒ£ Ø¥Ø±Ø³Ø§Ù„ ÙØ§ØªÙˆØ±Ø© Ø§Ù„Ø²Ø¨ÙˆÙ† (ÙˆØ§ØªØ³Ø§Ø¨)", url=f"https://wa.me/{OWNER_PHONE_NUMBER}?text={customer_final_text.replace(' ', '%20').replace('\n', '%0A').replace('*', '')}")],
            [InlineKeyboardButton("4ï¸âƒ£ Ø¥Ù†Ø´Ø§Ø¡ Ø·Ù„Ø¨ Ø¬Ø¯ÙŠØ¯", callback_data="start_new_order")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        message_text = "Ø§ÙØ¹Ù„ Ù…Ø§ ØªØ±ÙŠØ¯ Ù…Ù† Ø§Ù„Ø£Ø²Ø±Ø§Ø±:\n\n"
        if message_prefix:
            message_text = message_prefix + "\n" + message_text
        
        owner_invoice_details = []
        owner_invoice_details.append(f"Ø±Ù‚Ù… Ø§Ù„ÙØ§ØªÙˆØ±Ø©: {invoice}")
        owner_invoice_details.append(f"Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø²Ø¨ÙˆÙ†: {order['title']}")
        for p in order["products"]:
            if p in pricing.get(order_id, {}) and "buy" in pricing[order_id].get(p, {}) and "sell" in pricing[order_id].get(p, {}):
                buy = pricing[order_id][p]["buy"]
                sell = pricing[order_id][p]["sell"] 
                profit_item = sell - buy
                owner_invoice_details.append(f"{p} - Ø´Ø±Ø§Ø¡: {format_float(buy)}, Ø¨ÙŠØ¹: {format_float(sell)}, Ø±Ø¨Ø­: {format_float(profit_item)}")
            else:
                owner_invoice_details.append(f"{p} - (Ù„Ù… ÙŠØªÙ… ØªØ³Ø¹ÙŠØ±Ù‡ Ø¨Ø¹Ø¯)")
        owner_invoice_details.append(f"\nØ§Ù„Ù…Ø¬Ù…ÙˆØ¹ Ø´Ø±Ø§Ø¡: {format_float(total_buy)}")
        owner_invoice_details.append(f"Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹ Ø¨ÙŠØ¹: {format_float(total_sell)}")
        owner_invoice_details.append(f"Ø§Ù„Ø±Ø¨Ø­ Ø§Ù„ÙƒÙ„ÙŠ: {format_float(net_profit)}")
        owner_invoice_details.append(f"Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø­Ù„Ø§Øª: {current_places} (+{format_float(extra_cost)})")
        owner_invoice_details.append(f"Ø§Ù„Ø³Ø¹Ø± Ø§Ù„ÙƒÙ„ÙŠ: {format_float(final_total)}")
        
        final_owner_invoice_text = "\n".join(owner_invoice_details)
        
        encoded_owner_invoice = final_owner_invoice_text.replace(" ", "%20").replace("\n", "%0A").replace("*", "")
        whatsapp_owner_button_markup = InlineKeyboardMarkup([
            [InlineKeyboardButton("Ø¥Ø±Ø³Ø§Ù„ ÙØ§ØªÙˆØ±Ø© Ø§Ù„Ø¥Ø¯Ø§Ø±Ø© Ù„Ù„ÙˆØ§ØªØ³Ø§Ø¨", url=f"https://wa.me/{OWNER_PHONE_NUMBER}?text={encoded_owner_invoice}")]
        ])

        try:
            await context.bot.send_message(
                chat_id=OWNER_ID,
                text=f"**ÙØ§ØªÙˆØ±Ø© Ø·Ù„Ø¨ÙŠØ© (Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©):**\n{final_owner_invoice_text}",
                parse_mode="Markdown",
                reply_markup=whatsapp_owner_button_markup
            )
            logger.info(f"[{chat_id}] Admin invoice and WhatsApp button sent to OWNER_ID: {OWNER_ID}")
        except Exception as e:
            logger.error(f"[{chat_id}] Could not send admin invoice to OWNER_ID {OWNER_ID}: {e}", exc_info=True)
            await context.bot.send_message(chat_id=chat_id, text="Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù„Ù… Ø£ØªÙ…ÙƒÙ† Ù…Ù† Ø¥Ø±Ø³Ø§Ù„ ÙØ§ØªÙˆØ±Ø© Ø§Ù„Ø¥Ø¯Ø§Ø±Ø© Ø¥Ù„Ù‰ Ø®Ø§ØµÙƒ. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù†Ù†ÙŠ Ø£Ø³ØªØ·ÙŠØ¹ Ù…Ø±Ø§Ø³Ù„ØªÙƒ ÙÙŠ Ø§Ù„Ø®Ø§Øµ (Ù‚Ø¯ ØªØ­ØªØ§Ø¬ Ø¥Ù„Ù‰ Ø¨Ø¯Ø¡ Ù…Ø­Ø§Ø¯Ø«Ø© Ù…Ø¹ÙŠ Ø£ÙˆÙ„Ø§Ù‹).")

        await context.bot.send_message(chat_id=chat_id, text=message_text, reply_markup=reply_markup, parse_mode="Markdown")
        
        if user_id in context.user_data: 
            if 'messages_to_delete' in context.user_data[user_id]:
                for msg_info in context.user_data[user_id]['messages_to_delete']:
                    context.application.create_task(delete_message_in_background(context, chat_id=msg_info['chat_id'], message_id=msg_info['message_id']))
                context.user_data[user_id]['messages_to_delete'].clear()
            
            context.user_data[user_id].pop("order_id", None)
            context.user_data[user_id].pop("product", None)
            context.user_data[user_id].pop("current_active_order_id", None) 
            context.user_data[user_id].pop("buy_price", None) # Clear buy_price too
            logger.info(f"[{chat_id}] Cleaned up order-specific user_data for user {user_id} after showing final options. User data after clean: {json.dumps(context.user_data.get(user_id, {}), indent=2)}")
    except Exception as e:
        logger.error(f"[{chat_id}] Error in show_final_options: {e}", exc_info=True)
        await context.bot.send_message(chat_id=chat_id, text="Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¹Ø±Ø¶ Ø§Ù„ÙØ§ØªÙˆØ±Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¨Ø¯Ø¡ Ø·Ù„Ø¨ÙŠØ© Ø¬Ø¯ÙŠØ¯Ø©.")


async def edit_prices(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        query = update.callback_query
        await query.answer()
        
        user_id = str(query.from_user.id)
        logger.info(f"[{query.message.chat_id}] Edit prices callback from user {user_id}: {query.data}. User data: {json.dumps(context.user_data.get(user_id, {}), indent=2)}")
        if query.data.startswith("edit_prices_"):
            order_id = query.data.replace("edit_prices_", "")
        else:
            await query.message.reply_text("Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø²Ø±. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.")
            return ConversationHandler.END

        if order_id not in orders:
            logger.warning(f"[{query.message.chat_id}] Edit prices: Order {order_id} not found.")
            await query.message.reply_text("Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø§Ù„Ø·Ù„Ø¨ Ø§Ù„Ø°ÙŠ ØªØ­Ø§ÙˆÙ„ ØªØ¹Ø¯ÙŠÙ„Ù‡ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯.")
            return ConversationHandler.END

        if query.message:
            context.user_data.setdefault(user_id, {}).setdefault('messages_to_delete', []).append({
                'chat_id': query.message.chat_id,
                'message_id': query.message.message_id
            })
            logger.info(f"[{query.message.chat_id}] Added edit prices button message {query.message.message_id} to delete queue.")
            try:
                await context.bot.edit_message_reply_markup(
                    chat_id=query.message.chat_id,
                    message_id=query.message.message_id,
                    reply_markup=None 
                )
            except Exception as e:
                logger.warning(f"[{query.message.chat_id}] Could not clear buttons from edit prices message {query.message.message_id} directly: {e}. Proceeding.")
        
        await show_buttons(query.message.chat_id, context, user_id, order_id, confirmation_message="ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¢Ù† ØªØ¹Ø¯ÙŠÙ„ Ø£Ø³Ø¹Ø§Ø± Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª Ø£Ùˆ Ø¥Ø¶Ø§ÙØ©/Ø­Ø°Ù Ù…Ù†ØªØ¬Ø§Øª Ø¨ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø£ØµÙ„ÙŠØ© Ù„Ù„Ø·Ù„Ø¨ÙŠØ©.")
        logger.info(f"[{query.message.chat_id}] Showing edit buttons for order {order_id}. Exiting conversation for user {user_id}.")
        return ConversationHandler.END
    except Exception as e:
        logger.error(f"[{update.effective_chat.id}] Error in edit_prices: {e}", exc_info=True)
        await update.callback_query.message.reply_text("Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø£Ø³Ø¹Ø§Ø±. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¨Ø¯Ø¡ Ø·Ù„Ø¨ÙŠØ© Ø¬Ø¯ÙŠØ¯Ø©.")
        return ConversationHandler.END

async def start_new_order_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        query = update.callback_query
        await query.answer()
        
        user_id = str(query.from_user.id)
        logger.info(f"[{query.message.chat_id}] Start new order callback from user {user_id}. User data: {json.dumps(context.user_data.get(user_id, {}), indent=2)}")
        if user_id in context.user_data:
            context.user_data[user_id].pop("order_id", None)
            context.user_data[user_id].pop("product", None)
            context.user_data[user_id].pop("current_active_order_id", None)
            context.user_data[user_id].pop("messages_to_delete", None) 
            context.user_data[user_id].pop("buy_price", None) # Clear buy_price too
            logger.info(f"[{query.message.chat_id}] Cleared order-specific user_data for user {user_id} after starting a new order from button. User data after clean: {json.dumps(context.user_data.get(user_id, {}), indent=2)}")

        if query.message:
            context.application.create_task(delete_message_in_background(context, chat_id=query.message.chat_id, message_id=query.message.message_id))

        await query.message.reply_text("ØªÙ…Ø§Ù…ØŒ Ø¯Ø² Ø§Ù„Ø·Ù„Ø¨ÙŠØ© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© ÙƒÙ„Ù‡Ø§ Ø¨Ø±Ø³Ø§Ù„Ø© ÙˆØ§Ø­Ø¯Ø©.\n\n*Ø§Ù„Ø³Ø·Ø± Ø§Ù„Ø£ÙˆÙ„:* Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø²Ø¨ÙˆÙ†.\n*Ø§Ù„Ø£Ø³Ø·Ø± Ø§Ù„Ø¨Ø§Ù‚ÙŠØ©:* ÙƒÙ„ Ù…Ù†ØªØ¬ Ø¨Ø³Ø·Ø± ÙˆØ§Ø­Ø¯.", parse_mode="Markdown")
        
        return ConversationHandler.END
    except Exception as e:
        logger.error(f"[{update.effective_chat.id}] Error in start_new_order_callback: {e}", exc_info=True)
        await update.callback_query.message.reply_text("Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¨Ø¯Ø¡ Ø·Ù„Ø¨ Ø¬Ø¯ÙŠØ¯. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.")
        return ConversationHandler.END


async def show_profit(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        if str(update.message.from_user.id) != str(OWNER_ID):
            await update.message.reply_text("Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù…ØªØ§Ø­ Ù„Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·.")
            return
        logger.info(f"Current daily_profit requested by user {update.message.from_user.id}: {daily_profit}")
        await update.message.reply_text(f"Ø§Ù„Ø±Ø¨Ø­ Ø§Ù„ØªØ±Ø§ÙƒÙ…ÙŠ Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: *{format_float(daily_profit)}* Ø¯ÙŠÙ†Ø§Ø±", parse_mode="Markdown")
    except Exception as e:
        logger.error(f"[{update.effective_chat.id}] Error in show_profit: {e}", exc_info=True)
        await update.message.reply_text("Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¹Ø±Ø¶ Ø§Ù„Ø£Ø±Ø¨Ø§Ø­.")

async def reset_all(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        if str(update.message.from_user.id) != str(OWNER_ID):
            await update.message.reply_text("Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù…ØªØ§Ø­ Ù„Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·.")
            return
        
        keyboard = [
            [InlineKeyboardButton("Ù†Ø¹Ù…ØŒ Ù…ØªØ£ÙƒØ¯", callback_data="confirm_reset")],
            [InlineKeyboardButton("Ù„Ø§ØŒ Ø¥Ù„ØºØ§Ø¡", callback_data="cancel_reset")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text("Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† ØªØµÙÙŠØ± Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø±Ø¨Ø§Ø­ ÙˆÙ…Ø³Ø­ ÙƒÙ„ Ø§Ù„Ø·Ù„Ø¨Ø§ØªØŸ Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø¹Ù†Ù‡.", reply_markup=reply_markup)
    except Exception as e:
        logger.error(f"[{update.effective_chat.id}] Error in reset_all: {e}", exc_info=True)
        await update.message.reply_text("Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªØµÙÙŠØ±.")

async def confirm_reset(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        query = update.callback_query
        await query.answer()

        if str(query.from_user.id) != str(OWNER_ID):
            await query.edit_message_text("Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù„Ø§ ØªÙ…Ù„Ùƒ ØµÙ„Ø§Ø­ÙŠØ© Ù„ØªÙ†ÙÙŠØ° Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø±.")
            return

        if query.data == "confirm_reset":
            global daily_profit, orders, pricing, invoice_numbers, last_button_message
            logger.info(f"Daily profit before reset: {daily_profit}")
            daily_profit = 0.0
            orders.clear()
            pricing.clear()
            invoice_numbers.clear()
            last_button_message.clear()
            
            try:
                with open(COUNTER_FILE, "w") as f:
                    f.write("1")
            except Exception as e:
                logger.error(f"Could not reset invoice counter file: {e}", exc_info=True)

            _save_data_to_disk()
            logger.info(f"Daily profit after reset: {daily_profit}")
            await query.edit_message_text("ØªÙ… ØªØµÙÙŠØ± Ø§Ù„Ø£Ø±Ø¨Ø§Ø­ ÙˆÙ…Ø³Ø­ ÙƒÙ„ Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø¨Ù†Ø¬Ø§Ø­.")
        elif query.data == "cancel_reset":
            await query.edit_message_text("ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªØµÙÙŠØ±.")
    except Exception as e:
        logger.error(f"[{update.effective_chat.id}] Error in confirm_reset: {e}", exc_info=True)
        await update.callback_query.message.reply_text("Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªØµÙÙŠØ±.")

async def show_report(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        if str(update.message.from_user.id) != str(OWNER_ID):
            await update.message.reply_text("Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù…ØªØ§Ø­ Ù„Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·.")
            return
        
        total_orders = len(orders)
        total_products = 0
        total_buy_all_orders = 0.0 
        total_sell_all_orders = 0.0 
        product_counter = Counter()
        details = []

        for order_id, order in orders.items():
            invoice = invoice_numbers.get(order_id, "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ")
            details.append(f"\n**ÙØ§ØªÙˆØ±Ø© Ø±Ù‚Ù…:** {invoice}")
            details.append(f"**Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø²Ø¨ÙˆÙ†:** {order['title']}")
            
            order_buy = 0.0
            order_sell = 0.0
            
            if isinstance(order.get("products"), list):
                for p_name in order["products"]:
                    total_products += 1
                    product_counter[p_name] += 1
                    
                    if p_name in pricing.get(order_id, {}) and "buy" in pricing[order_id].get(p_name, {}) and "sell" in pricing[order_id].get(p_name, {}):
                        buy = pricing[order_id][p_name]["buy"]
                        sell = pricing[order_id][p_name]["sell"]
                        profit = sell - buy
                        order_buy += buy
                        order_sell += sell
                        details.append(f"  - {p_name} | Ø´Ø±Ø§Ø¡: {format_float(buy)} | Ø¨ÙŠØ¹: {format_float(sell)} | Ø±Ø¨Ø­: {format_float(profit)}")
                    else:
                        details.append(f"  - {p_name} | (Ù„Ù… ÙŠØªÙ… ØªØ³Ø¹ÙŠØ±Ù‡)")
            else:
                details.append(f"  (Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ù†ØªØ¬Ø§Øª Ù…Ø­Ø¯Ø¯Ø© Ù„Ù‡Ø°Ø§ Ø§Ù„Ø·Ù„Ø¨)")

            total_buy_all_orders += order_buy
            total_sell_all_orders += order_sell
            details.append(f"  *Ø±Ø¨Ø­ Ù‡Ø°Ù‡ Ø§Ù„Ø·Ù„Ø¨ÙŠØ©:* {format_float(order_sell - order_buy)}")

        top_product_str = "Ù„Ø§ ÙŠÙˆØ¬Ø¯"
        if product_counter:
            top_product_name, top_product_count = product_counter.most_common(1)[0]
            top_product_str = f"{top_product_name} ({top_product_count} Ù…Ø±Ø©)"

        result = (
            f"**--- ØªÙ‚Ø±ÙŠØ± Ø¹Ø§Ù… Ø¹Ù† Ø§Ù„Ø·Ù„Ø¨Ø§Øª ---**\n"
            f"**Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø¹Ø¯Ø¯ Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©:** {total_orders}\n"
            f"**Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª Ø§Ù„Ù…Ø¨Ø§Ø¹Ø© (ÙÙŠ Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©):** {total_products}\n"
            f"**Ø£ÙƒØ«Ø± Ù…Ù†ØªØ¬ ØªÙ… Ø·Ù„Ø¨Ù‡:** {top_product_str}\n\n"
            f"**Ù…Ø¬Ù…ÙˆØ¹ Ø§Ù„Ø´Ø±Ø§Ø¡ Ø§Ù„ÙƒÙ„ÙŠ (Ù„Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©):** {format_float(total_buy_all_orders)}\n"
            f"**Ù…Ø¬Ù…ÙˆØ¹ Ø§Ù„Ø¨ÙŠØ¹ Ø§Ù„ÙƒÙ„ÙŠ (Ù„Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©):** {format_float(total_sell_all_orders)}\n"
            f"**ØµØ§ÙÙŠ Ø§Ù„Ø±Ø¨Ø­ Ø§Ù„ÙƒÙ„ÙŠ (Ù„Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©):** {format_float(total_sell_all_orders - total_buy_all_orders)}\n" 
            f"**Ø§Ù„Ø±Ø¨Ø­ Ø§Ù„ØªØ±Ø§ÙƒÙ…ÙŠ ÙÙŠ Ø§Ù„Ø¨ÙˆØª (Ù…Ù†Ø° Ø¢Ø®Ø± ØªØµÙÙŠØ±):** {format_float(daily_profit)} Ø¯ÙŠÙ†Ø§Ø±\n\n"
            f"**--- ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø·Ù„Ø¨Ø§Øª ---**\n" + "\n".join(details)
        )
        await update.message.reply_text(result, parse_mode="Markdown")
    except Exception as e:
        logger.error(f"[{update.effective_chat.id}] Error in show_report: {e}", exc_info=True)
        await update.message.reply_text("Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¹Ø±Ø¶ Ø§Ù„ØªÙ‚Ø±ÙŠØ±.")

def main():
    app = ApplicationBuilder().token(TOKEN).build()

    # Handlers Ù„Ø§ ØªØ¯Ø®Ù„ ÙÙŠ Ø£ÙŠ ConversationHandler (Ù…Ø«Ù„ Ø§Ù„Ù€ /start ÙˆØ§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø¥Ø¯Ø§Ø±ÙŠØ©)
    app.add_handler(CommandHandler("start", start))
    app.add_handler(MessageHandler(filters.TEXT & filters.Regex("^Ø§Ù„Ø§Ø±Ø¨Ø§Ø­$|^Ø§Ø±Ø¨Ø§Ø­$"), show_profit))
    app.add_handler(MessageHandler(filters.TEXT & filters.Regex("^ØµÙØ±$|^ØªØµÙÙŠØ±$"), reset_all))
    app.add_handler(CallbackQueryHandler(confirm_reset, pattern="^(confirm_reset|cancel_reset)$"))
    app.add_handler(MessageHandler(filters.TEXT & filters.Regex("^Ø§Ù„ØªÙ‚Ø§Ø±ÙŠØ±$|^ØªÙ‚Ø±ÙŠØ±$|^ØªÙ‚Ø§Ø±ÙŠØ±$"), show_report))
    app.add_handler(MessageHandler(filters.UpdateType.EDITED_MESSAGE, edited_message))
    app.add_handler(CallbackQueryHandler(edit_prices, pattern="^edit_prices_"))
    app.add_handler(CallbackQueryHandler(start_new_order_callback, pattern="^start_new_order$"))

    # ConversationHandler Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø­Ù„Ø§Øª
    # ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ù‡Ø°Ø§ Ø§Ù„Ù€ ConversationHandler Ù‚Ø¨Ù„ Ø§Ù„Ù€ ConversationHandler Ø§Ù„Ø®Ø§Øµ Ø¨Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø·Ù„Ø¨
    # Ù„Ø¶Ù…Ø§Ù† Ø§Ù„ØªÙ‚Ø§Ø· Ø§Ù„ÙƒÙˆÙ„Ø¨Ø§ÙƒØ§Øª ÙˆØ§Ù„Ù†ØµÙˆØµ Ø§Ù„Ù…ØªØ¹Ù„Ù‚Ø© Ø¨Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø­Ù„Ø§Øª Ø£ÙˆÙ„Ø§Ù‹.
    places_conv_handler = ConversationHandler(
        entry_points=[
            CallbackQueryHandler(handle_places_count_data, pattern=r"^places_data_[a-f0-9]{8}_\d+$"),
            # Ù‡Ø°Ø§ ÙŠØ³ØªÙ‚Ø¨Ù„ Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ù†ØµÙŠ Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø­Ù„Ø§Øª ÙÙ‚Ø· Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø¨ÙˆØª ÙŠØ·Ù„Ø¨ Ø°Ù„Ùƒ.
            # ÙˆÙ„Ø§ ÙŠÙ…ÙƒÙ† Ø£Ù† ÙŠÙƒÙˆÙ† entry point ÙˆØ­Ø¯Ù‡ Ø¨Ø¯ÙˆÙ† Ø³ÙŠØ§Ù‚ ÙˆØ§Ø¶Ø­.
            # Ø³ÙŠØªÙ… ØªØ´ØºÙŠÙ„ Ù‡Ø°Ù‡ Ø§Ù„Ø­Ø§Ù„Ø© ÙÙ‚Ø· Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙÙŠ Ø­Ø§Ù„Ø© ASK_PLACES_COUNT Ù…Ù† conv_handler Ø¢Ø®Ø±.
            # Ù„Ø°Ù„Ùƒ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø£Ù† ÙŠÙƒÙˆÙ† Ù‡Ù†Ø§ ÙƒÙ€ entry_point Ø¨Ø§Ù„Ù…Ø¹Ù†Ù‰ Ø§Ù„ØªÙ‚Ù„ÙŠØ¯ÙŠ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù‡Ø¯Ù Ù‡Ùˆ Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ø¥Ù„ÙŠÙ‡.
            # Ù„Ù„ØªØ¨Ø³ÙŠØ·ØŒ Ø¯Ø§Ù„Ø© request_places_count_standalone Ù‡ÙŠ Ù…Ù† ØªØ¯Ø¹Ùˆ handle_places_count_data Ø¨Ø´ÙƒÙ„ Ù…Ø¨Ø§Ø´Ø±
            # Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ù…Ø­Ø§ÙˆÙ„Ø© "Ø¯Ø®ÙˆÙ„" Ø¥Ù„Ù‰ Ù‡Ø°Ø§ ConversationHandler.
        ],
        states={
            ASK_PLACES_COUNT: [
                # Ù‡Ø°Ø§ Ø§Ù„Ù†Ù…Ø· ÙŠØ³ØªÙ‚Ø¨Ù„ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¹Ø´Ø±ÙŠØ© ÙˆØ§Ù„ØµØ­ÙŠØ­Ø© Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø­Ù„Ø§Øª
                MessageHandler(filters.TEXT & filters.Regex(r"^\d+(\.\d+)?$") & ~filters.COMMAND, handle_places_count_data),
                # Ø¥Ø°Ø§ Ø¯Ø² Ø´ÙŠ Ù…Ùˆ Ø±Ù‚Ù…ÙŠ ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ø­Ø§Ù„Ø©ØŒ Ù†Ù†Ù‡ÙŠ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© Ø£Ùˆ Ù†Ø¹Ø·ÙŠÙ‡ Ø±Ø³Ø§Ù„Ø© Ø®Ø·Ø£
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_places_count_data), # Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø·Ù„Ø¨ Ø¨Ø±Ù‚Ù… ØµØ­ÙŠØ­
            ],
        },
        fallbacks=[
            CommandHandler("cancel", lambda u, c: ConversationHandler.END),
            # Fallback Ø¹Ø§Ù… Ø¥Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¯Ø² Ø´ÙŠ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹ ÙˆÙ‡Ùˆ ÙÙŠ Ù…Ø­Ø§Ø¯Ø«Ø© Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø­Ù„Ø§Øª
            MessageHandler(filters.ALL, lambda u, c: ConversationHandler.END) # ÙŠÙ†Ù‡ÙŠ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©
        ]
    )
    app.add_handler(places_conv_handler)
    
    # ConversationHandler Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø·Ù„Ø¨ ÙˆØªØ³Ø¹ÙŠØ± Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª
    # Ù‡Ø°Ø§ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø¨Ø¹Ø¯ Ø§Ù„Ù€ places_conv_handler Ù„Ø£Ù† Ø£Ø²Ø±Ø§Ø± places_conv_handler Ù‡ÙŠ Ø¬Ø²Ø¡ Ù…Ù† Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©.
    # Ø¨Ù…Ø§ Ø¥Ù† Ø§Ù„Ù€ `handle_places_count_data` ÙŠØªÙ… Ø§Ø³ØªØ¯Ø¹Ø§Ø¤Ù‡Ø§ Ù…Ø¨Ø§Ø´Ø±Ø©Ù‹ Ø¨Ø¹Ø¯ ØªØ³Ø¹ÙŠØ± ÙƒÙ„ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª
    # Ùˆ `request_places_count_standalone` Ù‡ÙŠ Ø§Ù„Ù„ÙŠ ØªØ±Ø³Ù„Ùƒ Ø£Ø²Ø±Ø§Ø± Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø­Ù„Ø§ØªØŒ
    # ÙØ§Ù„Ù…ÙØ±ÙˆØ¶ Ù…Ø§ÙƒÙˆ ØªØ¯Ø§Ø®Ù„ Ø¨ÙŠÙ† Ø§Ù„Ø§Ø«Ù†ÙŠÙ† Ù„Ø£Ù† ÙƒÙ„ ConversationHandler ÙŠÙ†Ù‡ÙŠ Ù†ÙØ³Ù‡ Ø¹Ù†Ø¯ Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡.
    order_creation_conv_handler = ConversationHandler(
        entry_points=[
            MessageHandler(filters.TEXT & ~filters.COMMAND, receive_order), # ÙŠØ³ØªÙ„Ù… Ø£ÙˆÙ„ Ø±Ø³Ø§Ù„Ø© Ù„Ù„Ø·Ù„Ø¨
            CallbackQueryHandler(product_selected, pattern=r"^[a-f0-9]{8}\|.+$") # ÙŠØ³ØªÙ„Ù… ÙƒÙˆÙ„Ø¨Ø§Ùƒ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ù†ØªØ¬
        ],
        states={
            ASK_BUY: [
                MessageHandler(filters.TEXT & filters.Regex(r"^\d+(\.\d+)?$") & ~filters.COMMAND, receive_buy_price),
                MessageHandler(filters.TEXT & ~filters.COMMAND, receive_buy_price), # Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø·Ù„Ø¨ Ø¨Ø±Ù‚Ù… ØµØ­ÙŠØ­
            ],
            ASK_SELL: [
                MessageHandler(filters.TEXT & filters.Regex(r"^\d+(\.\d+)?$") & ~filters.COMMAND, receive_sell_price),
                MessageHandler(filters.TEXT & ~filters.COMMAND, receive_sell_price), # Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø·Ù„Ø¨ Ø¨Ø±Ù‚Ù… ØµØ­ÙŠØ­
            ]
        },
        fallbacks=[
            CommandHandler("cancel", lambda u, c: ConversationHandler.END),
            MessageHandler(filters.ALL, lambda u, c: ConversationHandler.END) # ÙŠÙ†Ù‡ÙŠ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©
        ]
    )
    app.add_handler(order_creation_conv_handler)
    
    logger.info("Bot is running...")
    app.run_polling()

if __name__ == "__main__":
    main()
